(* Heavily modified from SML/NJ sources by sweeks@sweeks.com *)
(* Further modified from MLton by Gian Perrone *)

(* ml.grm
 *
 * Copyright 1989,1992 by AT&T Bell Laboratories
 *)

structure A = Ast
structure S = Symbol
structure T = Symtab

type clause = A.clause

type match = A.match

fun ensureNonqualified s = s

  %%
  %term
      CHAR of char 
    | INT of {digits: string,
              negate: bool,
              radix: StringCvt.radix}
    | LONGID of string
    | REAL of string
    | STRING of string 
    | TYVAR of string
    | WORD of {digits: string,
               radix: StringCvt.radix}
    | ABSTYPE | AND | ANDALSO | ARROW | AS | ASTERISK | BAR | CASE | COLON
    | COLONGT | COMMA | DATATYPE | DOTDOTDOT | ELSE | END | EOF | EQUALOP
    | EQTYPE | EXCEPTION | DO | DARROW | FN | FUN | FUNCTOR | HANDLE | HASH
    | IF | IN | INCLUDE | INFIX | INFIXR | LBRACE | LBRACKET | LET | LOCAL
    | LPAREN | NONFIX | ORELSE | OF | OP | OPEN | OVERLOAD | RAISE | RBRACE 
    | RBRACKET | REC | RPAREN | SEMICOLON | SHARING | SIG | SIGNATURE | STRUCT
    | STRUCTURE | THEN | TYPE | VAL | WHERE | WHILE | WILD | WITH | WITHTYPE
      (* Extensions *)
    | BUILD_CONST | COMMAND_LINE_CONST | CONST 
    | ADDRESS | EXPORT | IMPORT | SYMBOL 
    | PRIM

%nonterm
         aexp of A.exp
       | andspecs of unit
       | apat of A.pat
       | apat' of A.pat
       | apatnode of A.pat
       | apats of A.pat list
       | app_exp of A.exp list
       | app_exp1 of A.exp list
       | clause of clause
       | clauses of clause list
       | clausesTop of clause list
       | commapats of A.pat list
       | con of A.exp
       | const of A.exp
       | const' of A.exp
       | constr of A.exp * A.ty option
       | constraint of A.ty option
       | constrs of (A.exp * A.ty option) list
       | constOrBool of A.exp
       | datBind of A.bind list
       | datBindNoWithtype of A.bind list
       | datatypeRhs of A.bind list
       | datatypeRhsNoWithtype of A.bind list
       | datatypeRhsnode of A.bind list
       | datatypeRhsnodeNoWithtype of A.bind list
       | db of A.bind
       | dbs of A.bind list
       | dbs' of A.bind list
       | dec of A.dec
       | decnode of A.dec
       | decnolocal of A.dec
       | decs of A.dec list
       | decsnode of A.dec
       | digit of int
       | eb of unit 
       | ebrhs of unit
       | ebrhsnode of unit
       | ebs of unit
	   | elabel of (A.exp * A.exp)
       | elabels of (A.exp * A.exp) list
       | exndesc of A.exp * A.ty option
       | exndescs of (A.exp * A.ty option) list
       | exp of A.exp
       | exp_2c of A.exp list
       | exp_list of A.exp list
       | exp_ps of A.exp list
       | expnode of A.exp
       | expsAndTopdecs of A.dec list
       | fctarg of unit
       | fctid of unit
       | field of A.exp
       | fixity of A.fixity
       | funbinds of unit
       | funbinds' of unit
       | funbinds'1 of unit
       | funbinds'1' of unit
       | funbinds'2 of unit
       | funs of clause list list
       | id of A.symbol
       | idEqual of A.symbol
       | idNoAsterisk of A.symbol
       | int of int 
       | longcon of A.symbol 
       | longid of A.symbol
       | longidEqual of A.symbol
       | longidNoAsterisk of A.symbol
       | longtycon of A.ty
       | longtyconeqns of A.ty list
       | longvidands of A.symbol list
       | longvid of A.symbol
       | longvidNoEqual of A.symbol
       | match of match 
       | opaspat of A.pat option
       | opcon of A.exp
       | ot_list of A.exp list
       | pat of A.pat
       | pat_2c of A.pat list
       | patitem of A.pat
       | patitems of A.pat list * bool
	   | patnode of A.pat
       | pats of A.pat list
       | program of A.program
       | repl of A.bind list
       | rule of A.pat * A.exp
       | rules of match
       | rvalbind of A.bind list
       | rvalbindRest of A.bind list
(*     | sdec of unit
       | sdecs of unit
       | sdecsPlus of unit
       | sharespec of unit
       | sigbinds of unit
       | sigbinds' of unit
       | sigbinds'' of unit
       | sigconst of unit
       | sigexp of unit
       | sigexp' of unit
       | sigexp'node of unit
       | sigexpnode of unit
       | sigid of unit
       | sigids of unit
       | spec of Spec.t
       | specnode of Spec.node
       | specs of Spec.t
       | strbinds of strbind list
       | strbinds' of Strexp.t * strbind list
       | strbinds'1 of strbind whereAnd
       | strbinds'1' of strbind whereAnd
       | strbinds'2 of strbind list
       | strdec of Strdec.t
       | strdecnode of Strdec.node
       | strdecs of Strdec.t
       | strdecsnode of Strdec.node
       | strdescs of strdesc list
       | strdescs' of strdesc whereAnd
       | strdescs'' of strdesc whereAnd
       | strexp of Strexp.t
       | strexp1 of Strexp.t * (Sigexp.t -> SigConst.t) * Sigexp.t
       | strexp2 of Strexp.t
       | strexp2node of Strexp.node
       | strexpnode of Strexp.node
       | strid of Strid.t  *)
       | string of string
       | symattributes of unit 
       | tlabel of (A.exp * A.ty)
       | tlabels  of (A.exp * A.ty) list
       | topdec of A.dec
       | topdecnode of A.dec
       | topdecs of A.dec list
       | tuple_ty of A.ty list
       | ty of A.ty
       | ty' of A.ty
       | ty'node of A.ty
       | ty0_pc of A.ty list
       | ty1 of A.ty
       | tyOpt of A.ty option
       | tycon of A.ty
       | tynode of A.ty
       | typBind of A.bind list
       | typBind' of A.bind list 
       | typBind'' of A.bind list
       | typdesc of A.ty
       | typdescs of A.ty list
       | tyvar of A.ty
       | tyvar_pc of A.ty list
       | tyvars of A.ty list
       | tyvarseq of A.ty list
       | valbind of A.bind list * A.bind list
       | valbindRest of A.bind list * A.bind list
       | valbindTop of A.bind list * A.bind list
       | valdesc of unit
       | valdescs of unit
       | var of A.exp
       | vid of A.symbol
       | vidNoEqual of A.symbol
       | vids of A.symbol list
       | wherespec of unit
       | wherespecs of unit
       | wherespecs' of unit
       | withtypes of A.bind list
       | word of int

%verbose
%pos SourcePos.t
%eop EOF
%noshift EOF

%header (functor MLLrValsFun (structure Token: TOKEN))

%nonassoc WITHTYPE
%right AND
%right ARROW
%right DARROW 
%left DO
%left ELSE
%left RAISE
%right HANDLE
%left ORELSE
%left ANDALSO
%right AS
%left COLON

%name ML

%keyword ABSTYPE AND AS CASE DATATYPE DOTDOTDOT ELSE END 
  EQTYPE EXCEPTION  DO  DARROW  FN  FUN  FUNCTOR  HANDLE
  IF IN INCLUDE  INFIX  INFIXR  LET  LOCAL  NONFIX  OF  OP
  OPEN OVERLOAD  RAISE  REC  SHARING  SIG  SIGNATURE  STRUCT
  STRUCTURE THEN TYPE VAL WHILE WHERE WITH WITHTYPE
  ORELSE ANDALSO

%change -> VAL | -> THEN | -> ELSE | -> LPAREN | -> SEMICOLON | 
        DARROW -> EQUALOP | EQUALOP -> DARROW | AND -> ANDALSO | COLON -> OF |
        SEMICOLON -> COMMA | COMMA -> SEMICOLON |
        -> IN LONGID END | -> ELSE LONGID

%value CHAR (#"a")
%value INT ({digits = "0", negate = false, radix = StringCvt.DEC})
%value LONGID ("bogus")
%value REAL ("13.0")
%value STRING (Vector.fromList [])
%value TYVAR ("'a")
%value WORD ({digits = "0", radix = StringCvt.DEC})

%%

program: expsAndTopdecs (expsAndTopdecs)

expsAndTopdecs: decs (decs)

(*expsAndTopdecs:
    exp SEMICOLON expsAndTopdecs ((A.ExpDec {attr=[],exp=exp}) :: expsAndTopdecs)
  | topdecs (topdecs)

topdecs:
      ([])
  | topdec topdecs (topdec :: topdecs)
  | SEMICOLON expsAndTopdecs (expsAndTopdecs)

topdec : topdecnode (topdecnode)

topdecnode
   : decs  (decs)*)

(*---------------------------------------------------*)
(*                   Declarations                    *)
(*---------------------------------------------------*)

decs :                  ([])
     | dec decs         (dec :: decs)
     | SEMICOLON decs   (decs)

dec : decnode (decnode)

decnode : decnolocal              (decnolocal) 
        | LOCAL decs IN decs END  (A.LocalDec 
									{attr=[],dec1=decs1,dec2=decs,
									symtab=ref (T.empty ())})

decnolocal
        : VAL valbindTop          (A.ValDec {attr=[],
											tyvars = [],
                                            valBind = #1 valbindTop,
                                            recBind = #2 valbindTop})
        | VAL tyvarseq valbindTop  (A.ValDec {attr=[],
											tyvars = [],
                                            valBind = #1 valbindTop,
                                            recBind = #2 valbindTop})
        | FUN funs              (A.FunDec {attr=[],
											tyvars=[],
											clauses=funs})
        | FUN tyvarseq funs     (A.FunDec {attr=[],
											tyvars=tyvarseq,
											clauses=funs})
        | TYPE typBind          (A.TypeDec {attr=[],tyBind=typBind})
        | DATATYPE datatypeRhs  (A.DatatypeDec 
									{attr=[],tyBind=datatypeRhs})
        | ABSTYPE datBind WITH decs END   (A.AbstypeDec {attr=[],
														tyBind = datBind,
                                                        body = decs})
        | EXCEPTION ebs
          (A.ExceptionDec {attr=[]})
        | fixity vids           (A.FixDec {attr=[],fixity = fixity,
                                          ops = vids, symtab = T.top_level})

valbindTop : valbind (valbind)

valbind : pat EQUALOP exp valbindRest
          (let
              val (vbs, rvbs) = valbindRest
           in
              ((A.ValBind (pat,exp)) :: vbs,
               rvbs)
           end)
        | REC rvalbind                 (([], rvalbind))


valbindRest :                          (([], []))
            | AND valbind              (valbind)

rvalbind : REC rvalbind                (rvalbind)
         | pat EQUALOP FN match rvalbindRest
            ((A.ValRecBind (pat, match)) :: rvalbindRest)

rvalbindRest :               ([])
             | AND rvalbind  (rvalbind)

constraint :                    (NONE)
           | COLON ty           (SOME ty)

funs    : clausesTop               ([clausesTop])
        | clausesTop AND funs      (clausesTop :: funs)

clausesTop: clauses (clauses)

clauses : clause                ([clause])
        | clause BAR clauses    (clause :: clauses)

clause  : apats constraint EQUALOP exp  ({pats = apats,
                                          resultType = constraint,
                                          body = exp})

typBind : typBind' (typBind')

typBind' : tyvars tycon EQUALOP ty typBind''
           ((A.TypeBind {def = ty, tycon = tycon, tyvars = tyvars}) :: typBind'')

typBind'' :               ([])
          | AND typBind'  (typBind')


tyvars  : tyvarseq (tyvarseq)
        |          ([])

tyvarseq: tyvar                   ([tyvar])
        | LPAREN tyvar_pc RPAREN  (tyvar_pc)

tyvar_pc: tyvar                ([tyvar])
        | tyvar COMMA tyvar_pc (tyvar :: tyvar_pc)

constrs : constr                ([constr])
        | constr BAR constrs    (constr :: constrs)

constr  : opcon         (opcon, NONE)
        | opcon OF ty   (opcon, SOME ty)

opcon   : con           (con)
        | OP con        (con)

fixity  : INFIX                 (A.Infix NONE)
        | INFIX digit           (A.Infix (SOME digit))
        | INFIXR                (A.Infixr NONE)
        | INFIXR digit          (A.Infixr (SOME digit))
        | NONFIX                (A.Nonfix)

int : INT
   (let
       val {digits, negate, radix} = INT
    in
       case Int.fromString digits of
          NONE => raise (Fail "parser saw invalid int")
        | SOME i => if negate then ~ i else i
    end)

word : WORD
   (let
       val {digits, radix} = WORD
    in
       case Int.fromString digits of
          NONE => raise (Fail "parser saw invalid word")
        | SOME i => i
    end)

digit : INT
   (let
       val {digits, negate, radix} = INT
    in
       if 1 = String.size digits andalso not negate andalso radix = StringCvt.DEC
          then valOf (Int.fromString digits)
       else raise (Fail "invalid digit in infix declaration")
    end)

datatypeRhs
   : datatypeRhsnode	(datatypeRhsnode)

datatypeRhsNoWithtype
   : datatypeRhsnodeNoWithtype (datatypeRhsnodeNoWithtype)

datatypeRhsnode
   : repl              (repl)
   | datBind           (datBind)

datatypeRhsnodeNoWithtype
   : repl               (repl)
   | datBindNoWithtype  (datBindNoWithtype)

repl : tyvars tycon EQUALOP DATATYPE longtycon
       (if length tyvars = 0
           then ()
        else raise (Fail "nonempty tyvars in datatype repl")
        ; [A.DatatypeReplBind {lhs = tycon, rhs = longtycon}])

datBind
   : dbs withtypes	(dbs @ withtypes)

datBindNoWithtype
   : dbs (dbs)

dbs : dbs' (dbs')

dbs'
   : db
     ([db])
   | db AND dbs'
     (db :: dbs')

db : tyvars tycon EQUALOP constrs
     (A.DatatypeBind {cons = constrs,
       tycon = tycon,
       tyvars = tyvars})

withtypes
   :
     ([])
   | WITHTYPE typBind
     (typBind)

longvidands : longvid  ([longvid])
            | longvid AND longvidands (longvid :: longvidands)

match : rules           (rules)

rules : rule            ([rule])
      | rule BAR rules  (rule :: rules)

rule    : pat DARROW exp        ((pat,exp))

elabel  : field EQUALOP exp     (field,exp)

elabels : elabel COMMA elabels  (elabel :: elabels)
        | elabel                ([elabel])

exp_ps  : exp SEMICOLON exp     ([exp1, exp2])
        | exp SEMICOLON exp_ps  (exp :: exp_ps)

exp : expnode (expnode)

expnode : exp HANDLE match      (A.Handle {attr=[],exp=exp, match=match})
        | exp ORELSE exp        (A.BinOp
								 {attr=[],opr=A.BOr,lhs=exp1,rhs=exp2})
        | exp ANDALSO exp       (A.BinOp 
								{attr=[],opr=A.BAnd,lhs=exp1,rhs=exp2})
        | exp COLON ty          (A.Constraint {attr=[],exp=exp,ty=ty})
        | app_exp               (A.App {attr=[],exps=app_exp})
        | FN match              (A.Fn {attr=[],match=match,
							  	 symtab=ref (T.empty ())})
        | CASE exp OF match     (A.Case {attr=[],exp=exp,match=match})
        | WHILE exp DO exp      (A.While {attr=[],test=exp1,exp = exp2})
        | IF exp THEN exp ELSE exp 
						(A.If {attr=[],cond=exp1,tbr=exp2,fbr=exp3})
        | RAISE exp             (A.Raise {attr=[],exp=exp})

app_exp : aexp app_exp1     (aexp :: app_exp1)
        | longvid app_exp1  ((A.Var {attr=[],name = longvid,
									symtab=T.top_level}) :: app_exp1)

app_exp1 :         ([])
         | app_exp (app_exp)

aexp    : OP longvid            (A.Op {attr=[],symbol = longvid, 
										symtab = T.top_level})
        | const                 (const)
        | HASH field            (A.Selector {attr=[],exp=field})
        | LBRACE elabels RBRACE (A.Record {attr=[],fields=elabels})
        | LBRACE RBRACE         (A.Unit)
        | LPAREN RPAREN         (A.Unit)
        | LPAREN expnode RPAREN (expnode)
        | LPAREN exp_ps RPAREN  (A.Seq {attr=[],exps=exp_ps})
        | LPAREN exp_2c RPAREN  (A.Tuple {attr=[],exps=exp_2c})
        | LBRACKET exp_list RBRACKET  (A.List {attr=[],exps=exp_list})
        | LBRACKET RBRACKET           (A.List {attr=[],exps=[]})
        | LET decs IN exp END   (A.Let {attr=[],decs=decs,exp=exp,
										symtab=ref (T.empty ())})
        | LET decs IN exp_ps END
            (A.Let {attr=[],decs=decs,exp=(A.Seq {attr=[],exps=exp_ps}),
					 symtab=ref (T.empty ())})

exp_2c  : exp COMMA exp_2c      (exp :: exp_2c)
        | exp COMMA exp         ([exp1, exp2])

exp_list : exp                  ([exp])
         | exp COMMA exp_list   (exp :: exp_list)

(*---------------------------------------------------*)
(*                     Patterns                      *)
(*---------------------------------------------------*)

pat : patnode (patnode)

patnode : pat AS pat    (A.AsPat (pat1, pat2))
        | pat COLON ty  (A.ConstraintPat (pat, ty))
        | apats         (A.AppPat apats)

apats   : apat                  ([apat])
        | apat apats            (apat :: apats)

apat : apatnode (apatnode)

apatnode : longvidNoEqual        (A.VarPat {attr=[],name=longvidNoEqual,
											symtab=T.top_level})
        | OP longvid             (A.OpPat {attr=[],symbol= longvid,
											symtab=T.top_level})
        | const
          (case const of
           A.Real _ => 
		   	raise (Fail "real constants are not allowed in patterns")
                | _ => A.ConstPat const)
        | WILD                   (A.WildPat)
        | LPAREN pats RPAREN     (A.TuplePat pats)
        | LBRACKET pats RBRACKET (A.ListPat pats)
        | LBRACE RBRACE          (A.UnitPat)
        | LBRACE patitems RBRACE
          (let
              val (items, flexible) = patitems
           in
              A.RecordPat {flexible = flexible,
                          pats = items}
           end)

pats: ([])
    | pat commapats (pat :: commapats)

commapats : ([])
          | COMMA pat commapats (pat :: commapats)

patitems : patitem COMMA patitems  (let val (items, f) = patitems
                                    in (patitem :: items, f)
                                    end)
         | patitem              ([patitem], false)
         | DOTDOTDOT            ([], true)

patitem
   : field EQUALOP pat (A.FieldPat (field, pat))
   | vidNoEqual constraint opaspat
     (let
		val p = A.VarPat {attr=[],name=vidNoEqual,symtab=T.top_level}
		val p' = (case constraint of
					NONE => p
				  | SOME x => A.ConstraintPat (p,x))
		val p'' = (case opaspat of
				    NONE => p'
				  | SOME x => A.AsPat (p',x))
	 in
	 	p''
	 end)

opaspat :         (NONE)
        | AS pat  (SOME pat)

(*---------------------------------------------------*)
(*                       Types                       *)
(*---------------------------------------------------*)

ty : tynode (tynode)

tynode  : tuple_ty      (A.TupleTy (tuple_ty))
        | ty ARROW ty   (A.ArrowTy (ty1, ty2))
        | ty'node       (ty'node)

ty' : ty'node (ty'node)

ty'node : tyvar                           (tyvar)
        | LBRACE tlabels RBRACE           (A.RecordTy (tlabels))
        | LBRACE RBRACE                   (A.UnitTy)
        | LPAREN ty0_pc RPAREN longtycon  (A.TyConTy (longtycon, ty0_pc))
        | LPAREN ty RPAREN                (ty)
        | ty' longtycon                   (A.TyConTy (longtycon, [ty']))
        | longtycon                       (A.TyConTy (longtycon,[]))

tlabel  : field COLON ty        (field, ty)

tlabels : tlabel COMMA tlabels  (tlabel :: tlabels)
        | tlabel                ([tlabel])

tuple_ty : ty' ASTERISK tuple_ty        (ty' :: tuple_ty)
         | ty' ASTERISK ty'             ([ty'1, ty'2])

ty0_pc  : ty COMMA ty           ([ty1, ty2])
        | ty COMMA ty0_pc       (ty :: ty0_pc)

(*---------------------------------------------------*)
(*                       Atoms                       *)
(*---------------------------------------------------*)

constOrBool
   : const (const)
   | id (case Symbol.toString id of
         	"false" => A.Bool false
          | "true" => A.Bool true
          | s => raise Fail "Invalid bool constant")

const   : const'                (const')

const'  : int                   (A.Int int)
        | word                  (A.Word (Word32.fromInt word))
        | REAL                  (A.Real (valOf (Real.fromString REAL)))
        | STRING                (A.String STRING)
        | CHAR                  (A.Char CHAR)

string : STRING  (STRING)

idNoAsterisk : longidNoAsterisk (ensureNonqualified longidNoAsterisk)

id : idNoAsterisk  (idNoAsterisk)
   | ASTERISK      (S.asterisk)

idEqual : id      (id)
        | EQUALOP (S.equal)

longid
   : longidNoAsterisk (longidNoAsterisk)
   | ASTERISK  (S.asterisk)

longidNoAsterisk
   : LONGID						(S.fromString LONGID)

longidEqual : longid   (longid)
            | EQUALOP  (S.equal)

vid : idEqual                  (idEqual)
vidNoEqual : id                (id)
vids : vid                     ([vid])
     | vid vids                (vid::vids)
con : id                       (A.Var {attr=[],name=id,symtab=T.top_level})
tycon : idNoAsterisk           (A.VarTy (idNoAsterisk,T.top_level))
tyvar : TYVAR                  (A.VarTy (S.fromString TYVAR,T.top_level))
field : id                     (A.Var {attr=[],name=id,symtab=T.top_level})
      | int                    (A.Int
                                 (if int <= 0
                                   then raise Fail "nonpositive field"
                                    else
                                       int - 1))

longtycon : longidNoAsterisk 	(A.VarTy (longidNoAsterisk,T.top_level)) 
longvid : longidEqual      		(longidEqual) 
longvidNoEqual : longid    		(longid) 
longcon : longid           		(longid) 


